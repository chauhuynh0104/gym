
<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>L·∫≠p L·ªãch Th·ªß Thu·∫≠t </title>
  <style>body {
  font-family: 'Inter', sans-serif;
}
    :root {
      --bg: #f7f9fc;
      --card: #ffffff;
      --muted: #6b7280;
      --txt: #0b1220;
      --acc: #1f6aff;
      --chip: #eef2ff;
      --ok: #059669;
      --warn: #b45309;
      --bad: #b91c1c;
      --border: #e2e8f0;
    }
    html, body { background: var(--bg); color: var(--txt); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji"; margin: 0; }
    h1 { font-size: 22px; margin: 16px; }
    .container { max-width: 1100px; margin: 0 auto; padding: 12px; }
 .card {
  background: var(--card);
  border-radius: 16px;
  padding: 20px;
  margin-bottom: 16px;
  box-shadow: 0 4px 20px rgba(0,0,0,0.05);
  border: 1px solid var(--border);
  backdrop-filter: blur(10px);
  background: #FFFFFF;
  
}    .row { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; margin-bottom: 8px; }
    .row > * { flex: 1 1 auto; }
    label { font-size: 12px; color: var(--muted); display: block; margin-bottom: 4px; }
input[type="text"], input[type="time"], input[type="number"], select {
  width: 50%;
  padding: 12px 14px;
  border-radius: 10px;
  border: 1px solid var(--border);
  background: var(--input-bg);
  color: var(--txt);
  font-size: 14px;
  transition: 0.25s;
}



input:focus, select:focus {
  outline: none;
  border-color: var(--acc);
  box-shadow: 0 0 0 3px rgba(31,106,255,0.25);
}  .btn {
  cursor: pointer;
  background: linear-gradient(135deg, #1f6aff, #4facfe);
  border: none;
  color: #fff;
  padding: 10px 16px;
  border-radius: 12px;
  font-weight: 600;
  transition: 0.25s;
}

.btn:hover {
  transform: translateY(-2px);
  box-shadow: 0 6px 16px rgba(31,106,255,0.3);
}    .btn-small { padding: 6px 10px; font-size: 12px; border-radius: 10px; }
    .chip { display: inline-flex; align-items: center; gap: 6px; background: var(--chip); border: 1px solid var(--border); padding: 6px 10px; border-radius: 999px; font-size: 12px; color: var(--txt); }
    .chips { display: flex; gap: 8px; flex-wrap: wrap; }
    .muted { color: var(--muted); }
    .grid2 { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    .hidden { display: none; }
table {
  width: 100%;
  border-collapse: collapse;
  border-radius: 12px;
  overflow: hidden;
}    th, td { padding: 10px 12px; border-bottom: 1px solid var(--border); text-align: left; }
  thead th {
  background: var(--acc);
  color: #fff;
  text-align: left;
  padding: 12px;
  position: sticky;
  top: 0;
}
    .tag { font-size: 11px; padding: 2px 8px; border-radius: 999px; border: 1px solid var(--border); background: #ffffff; }
    .tag-ok { border-color: rgba(20,184,166,.3); color: var(--ok); }
    .tag-warn { border-color: rgba(251,191,36,.3); color: var(--warn); }
    .tag-bad { border-color: rgba(239,68,68,.3); color: var(--bad); }
    .section-title { font-weight: 700; margin-top: 6px; }
    .divider { height: 1px; background: var(--border); margin: 10px 0; }

    .overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.5); display: none; align-items: center; justify-content: center; z-index: 9999; }
    .modal { background: #fff; padding: 18px 20px; border-radius: 14px; max-width: 720px; width: calc(100% - 32px); box-shadow: 0 6px 20px rgba(0,0,0,0.25); font-size: 14px; }
    .modal-header { display:flex; align-items:center; justify-content: space-between; margin-bottom: 12px; }
    .modal-title { font-weight:700; }
    .modal-actions { display:flex; gap:8px; }

    #popupOverlay { position: fixed; top:0; left:0; width:100%; height:100%; background: rgba(0,0,0,0.5); display:none; align-items:center; justify-content:center; z-index:9999; }
    #popupBox { background:#fff; padding:20px 28px; border-radius:12px; max-width:320px; text-align:center; box-shadow:0 6px 20px rgba(0,0,0,0.25); font-size:14px; }
    #popupBox button { margin-top:14px; padding:8px 14px; border:none; background: var(--acc); color:#fff; border-radius:8px; cursor:pointer; }
    #popupBox button:hover { opacity:.9; }

    #historyTable th, #historyTable td { white-space: nowrap; }
    .nowrap { white-space: nowrap; }
	
	tbody tr:nth-child(even) { background: #f9fbff; }
tbody tr:hover { background: #eef4ff; }
  </style><link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
</head>
<body>
  <div class="container">

    <!-- 1. Nh√¢n vi√™n + L·ªãch s·ª≠ -->
    <div class="card" id="staffCard">
      <div class="row" style="justify-content: space-between; align-items:center;">
        <div class="section-title">1. T√™n nh√¢n vi√™n</div>
        <div style="flex:0 0 auto; display:flex; gap:8px;">
          <button class="btn btn-small" id="historyBtn">üìú L·ªãch s·ª≠</button>
        </div>
      </div>
      <div id="staffList"></div>
    </div>

    <!-- 2. B·ªánh nh√¢n & th·ªß thu·∫≠t -->
    <div class="card" id="patientsCard">
      <div class="row"><div class="section-title">2. B·ªánh nh√¢n & th·ªß thu·∫≠t</div></div>
      <div id="patients"></div>
      <button class="btn btn-small" id="addPatientBtn">+ Th√™m b·ªánh nh√¢n</button>
      <div class="divider"></div>
      <div class="grid2">
        <div>
          <label>Gi·ªù b·∫Øt ƒë·∫ßu bu·ªïi s√°ng</label>
          <input type="time" id="morningStart" value="07:30">
        </div>
        <div>
          <label>Gi·ªù k·∫øt th√∫c bu·ªïi s√°ng</label>
          <input type="time" id="morningEnd" value="11:30">
        </div>
        <div>
          <label>Gi·ªù b·∫Øt ƒë·∫ßu bu·ªïi chi·ªÅu</label>
          <input type="time" id="afternoonStart" value="13:30">
        </div>
        <div>
          <label>Gi·ªù k·∫øt th√∫c bu·ªïi chi·ªÅu</label>
          <input type="time" id="afternoonEnd" value="17:00">
        </div>
      </div>
    </div>

    <!-- 3-5. M√°y m√≥c -->
    <div class="card" id="machinesCard">
      <div class="row"><div class="section-title">3. M√°y</div></div>
      <div class="row">
        <div>
          <label>S·ªë l∆∞·ª£ng m√°y ƒëi·ªán ch√¢m</label>
          <input type="number" min="0" id="nDienCham" value="0">
        </div>
        <div id="dienChamNames"></div>
      </div>
      <div class="row">
        <div>
          <label>S·ªë l∆∞·ª£ng m√°y chi·∫øu ƒë√®n</label>
          <input type="number" min="0" id="nChieuDen" value="0">
        </div>
        <div id="chieuDenNames"></div>
      </div>
      <div class="row">
        <div>
          <label>S·ªë l∆∞·ª£ng m√°y gi√°c h∆°i</label>
          <input type="number" min="0" id="nGiacHoi" value="0">
        </div>
        <div id="giacHoiNames"></div>
      </div>
    </div>

    <!-- Actions & Results -->
    <div class="card">
      <div class="row" style="justify-content: space-between;">
        <button class="btn" id="startBtn">B·∫Øt ƒë·∫ßu s·∫Øp x·∫øp</button>
      </div>
      <div class="divider"></div>
      <div id="outputWrap" class="hidden">
        <div class="row" style="justify-content: space-between; align-items:center;">
          <div class="section-title">Gi·ªù th·ªß thu·∫≠t</div>
          <div class="row" style="flex:0 0 auto; gap:8px;">
            <button class="btn btn-small" id="exportCSV">T·∫£i CSV</button>
            <button class="btn btn-small" id="copyCSV">Copy CSV</button>
            <button class="btn btn-small" id="exportExcel">T·∫£i Excel</button>
          </div>
        </div>
        <div style="overflow:auto;">
          <table id="resultTable">
            <thead>
              <tr>
                <th>B·ªánh nh√¢n</th>
                <th>Th·ªß thu·∫≠t</th>
                <th>Nh√¢n vi√™n</th>
                <th>M√°y</th>
                <th>B·∫Øt ƒë·∫ßu</th>
                <th>K·∫øt th√∫c</th>
                <th>Nh√¢n vi√™n b·∫≠n</th>
                <th>Ghi ch√∫</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
      </div>
    </div>
  </div>

  <!-- Small alert popup -->
  <div id="popupOverlay"><div id="popupBox"><div id="popupMessage"></div><button onclick="closePopup()">OK</button></div></div>

  <!-- History list modal -->
  <div class="overlay" id="historyOverlay">
    <div class="modal">
      <div class="modal-header">
        <div class="modal-title">üìú L·ªãch s·ª≠ s·∫Øp x·∫øp </div>
        <div class="modal-actions">
          <button class="btn btn-small" id="clearHistoryBtn">X√≥a t·∫•t c·∫£</button>
          <button class="btn btn-small" id="closeHistoryBtn">ƒê√≥ng</button>
        </div>
      </div>
      <div style="overflow:auto; max-height: 60vh;">
        <table id="historyTable">
          <thead>
            <tr>
              <th>T√™n file</th>
              <th>Ng√†y gi·ªù</th>
              <th>S·ªë d√≤ng</th>
              <th>S·ªë b·ªánh nh√¢n</th>
              <th class="nowrap">Xem</th>
              <th class="nowrap">X√≥a</th>
            </tr>
          </thead>
          <tbody id="historyListBody"></tbody>
        </table>
      </div>
    </div>
  </div>

  <!-- History detail modal -->
  <div class="overlay" id="historyDetailOverlay">
    <div class="modal">
      <div class="modal-header">
        <div class="modal-title" id="historyDetailTitle">L·ªãch th·ªß thu·∫≠t ƒë√£ s·∫Øp</div>
        <div class="modal-actions">
          <button class="btn btn-small" id="closeHistoryDetailBtn">ƒê√≥ng</button>
        </div>
      </div>
      <div style="overflow:auto; max-height: 70vh;">
        <table style="width:100%;" id="historyDetailTable">
          <thead>
            <tr>
              <th>B·ªánh nh√¢n</th>
              <th>Th·ªß thu·∫≠t</th>
              <th>Nh√¢n vi√™n</th>
              <th>M√°y</th>
              <th>B·∫Øt ƒë·∫ßu</th>
              <th>K·∫øt th√∫c</th>
              <th>Nh√¢n vi√™n b·∫≠n</th>
              <th>Ghi ch√∫</th>
            </tr>
          </thead>
          <tbody id="historyDetailBody"></tbody>
        </table>
      </div>
    </div>
  </div>

<script>
/*
  Dropbox-backed history for scheduler.
  WARNING: this script contains app secret + refresh token (provided by user).
  Keep this file secure.
*/

/* ======= C·∫§U H√åNH DROPBOX =======
   B·∫°n ƒë√£ cung c·∫•p (ƒë√£ ch√®n tr·ª±c ti·∫øp v√†o code):
   - refreshToken
   - APP_KEY
   - APP_SECRET
   Thao t√°c OAuth2: d√πng refresh token ƒë·ªÉ l·∫•y access token, sau ƒë√≥ g·ªçi endpoint content API.
*/
const DROPBOX = {
  refreshToken: 'O4v-xPPKvnAAAAAAAAAAATLzEX47vCTSEpoiR55IjJC5isF2DsSoKTckCkGP2RQA',
  appKey: 'z19htlmxpaes9jb',
  appSecret: '3168y37xae5fw0h',
  // th∆∞ m·ª•c g·ªëc trong App folder: ta l∆∞u d∆∞·ªõi /scheduler_history_v1
  baseFolder: '/scheduler_history_v1'
};

/* Token cache in-memory */
let _dbxToken = null; // {access_token, expires_at(ms)}
async function dbxGetAccessToken() {
  const now = Date.now();
  if (_dbxToken && _dbxToken.expires_at && _dbxToken.expires_at > now + 5000) {
    return _dbxToken.access_token;
  }
  // exchange refresh token
  const url = 'https://api.dropbox.com/oauth2/token';
  const body = new URLSearchParams();
  body.append('grant_type','refresh_token');
  body.append('refresh_token', DROPBOX.refreshToken);
  // Use Basic auth with client_id:client_secret
  const basic = btoa(`${DROPBOX.appKey}:${DROPBOX.appSecret}`);
  try {
    const res = await fetch(url, { method:'POST', headers:{ 'Authorization':'Basic '+basic, 'Content-Type':'application/x-www-form-urlencoded' }, body: body.toString() });
    if (!res.ok) {
      throw new Error('Kh√¥ng l·∫•y ƒë∆∞·ª£c access token t·ª´ Dropbox: ' + res.status + ' ' + res.statusText);
    }
    const j = await res.json();
    if (!j.access_token) throw new Error('Response kh√¥ng c√≥ access_token');
    _dbxToken = { access_token: j.access_token, expires_at: Date.now() + (j.expires_in ? j.expires_in*1000 : 50*60*1000) };
    return _dbxToken.access_token;
  } catch (e) {
    console.error(e);
    showPopup('L·ªói k·∫øt n·ªëi Dropbox: ' + (e.message || e));
    throw e;
  }
}

/* Upload raw bytes or text to Dropbox content API as a file (overwrite) */
async function dropboxUpload(path, data, mode='overwrite') {
  const token = await dbxGetAccessToken();
  const url = 'https://content.dropboxapi.com/2/files/upload';
  const args = { path, mode: {'.tag': mode}, autorename: false, mute: true, strict_conflict: false };
  const res = await fetch(url, { method:'POST', headers:{
    'Authorization':'Bearer '+token,
    'Content-Type':'application/octet-stream',
    'Dropbox-API-Arg': JSON.stringify(args)
  }, body: data });
  if (!res.ok) {
    const t = await res.text();
    throw new Error('Upload th·∫•t b·∫°i: ' + res.status + ' ' + t);
  }
  return res.json();
}

/* Download a file's content from Dropbox (content/download) */
async function dropboxDownload(path) {
  const token = await dbxGetAccessToken();
  const url = 'https://content.dropboxapi.com/2/files/download';
  const res = await fetch(url, { method:'POST', headers:{
    'Authorization':'Bearer '+token,
    'Dropbox-API-Arg': JSON.stringify({ path })
  }});
  if (!res.ok) {
    if (res.status === 409 || res.status === 409) return null;
    const t = await res.text();
    throw new Error('Download th·∫•t b·∫°i: ' + res.status + ' ' + t);
  }
  const txt = await res.text();
  return txt;
}

/* Delete a file (files/delete_v2) */
async function dropboxDelete(path) {
  const token = await dbxGetAccessToken();
  const url = 'https://api.dropboxapi.com/2/files/delete_v2';
  const res = await fetch(url, { method:'POST', headers:{
    'Authorization':'Bearer '+token,
    'Content-Type':'application/json'
  }, body: JSON.stringify({ path }) });
  if (!res.ok) {
    const t = await res.text();
    throw new Error('X√≥a th·∫•t b·∫°i: ' + res.status + ' ' + t);
  }
  return res.json();
}

/* Ensure base folder exists (App folder may already allow writing to base path) 
   We'll attempt to create folder; if exists, ignore error.
*/
async function ensureBaseFolder() {
  const token = await dbxGetAccessToken();
  const url = 'https://api.dropboxapi.com/2/files/create_folder_v2';
  try {
    const res = await fetch(url, { method:'POST', headers:{
      'Authorization':'Bearer '+token,
      'Content-Type':'application/json'
    }, body: JSON.stringify({ path: DROPBOX.baseFolder, autorename:false }) });
    if (!res.ok) {
      const j = await res.json().catch(()=>null);
      // If folder exists, dropbox returns specific error - ignore
      if (j && j.error && j.error['.tag'] === 'path' && j.error.path['.tag'] === 'conflict') {
        return;
      }
      // else if already exists, ignore
      // in many cases create_folder_v2 returns 409 if exists; swallow that
    }
  } catch (e) {
    // non-blocking ‚Äì ignore if can't create (folder may already exist)
    console.warn('ensureBaseFolder error', e);
  }
}

/* Path helpers */
function indexPath() { return `${DROPBOX.baseFolder}/index.json`; }
function itemPath(id) { return `${DROPBOX.baseFolder}/${id}.json`; }

/* ====== Scheduler code (unchanged logic) ====== */

/* Helpers for time */
function toMin(hhmm) { if (!hhmm) return 0; const [h,m] = hhmm.split(':').map(x=>parseInt(x,10)); return h*60+m; }
function toHHMM(min) { min = Math.max(0, Math.round(min)); const h = Math.floor(min/60); const m = min%60; return (h<10?'0':'')+h+':' + (m<10?'0':'')+m; }

/* ... staff/patients/procedures code (same as before) ... */
// We'll reuse the same UI creation functions from original file (slightly trimmed for brevity)
const staffListEl = document.getElementById('staffList');
function addStaffInput(value='') {
  const row = document.createElement('div'); row.className = 'row';
  const wrap = document.createElement('div'); wrap.style.flex = '1 1 300px';
  const label = document.createElement('label'); label.textContent = '';
  const input = document.createElement('input'); input.type='text'; input.placeholder='Nh·∫≠p t√™n nh√¢n vi√™n'; input.value=value; input.addEventListener('input', onStaffTyping);
  wrap.appendChild(label); wrap.appendChild(input); row.appendChild(wrap); staffListEl.appendChild(row);
}
function onStaffTyping(e) {
  const inputs = staffListEl.querySelectorAll('input[type="text"]');
  const last = inputs[inputs.length-1];
  if (e.target === last && last.value.trim() !== '') { addStaffInput(''); refreshPatientStaffOptions(); }
  else { refreshPatientStaffOptions(); }
}
addStaffInput('');

const patientsEl = document.getElementById('patients');
const addPatientBtn = document.getElementById('addPatientBtn');

const PROCEDURES = [
  {key:'dien_cham', label:'ƒêi·ªán ch√¢m [kim ng·∫Øn]', duration:20, staffActive:3, patientActive:20, deviceType:'dienCham', allowOverlapWith:['chieu_den_after_3']},
  {key:'chieu_den', label:'ƒêi·ªÅu tr·ªã b·∫±ng tia h·ªìng ngo·∫°i', duration:10, staffActive:1, patientActive:10, deviceType:'chieuDen', allowOverlapWith:[]},
  {key:'xoa_bop', label:'Xoa b√≥p b·∫•m huy·ªát b·∫±ng tay', duration:30, staffActive:30, patientActive:30, deviceType:null, allowOverlapWith:[]},
  {key:'xoa_bop_vung', label:'K·ªπ thu·∫≠t xoa b√≥p v√πng', duration:15, staffActive:15, patientActive:15, deviceType:null, allowOverlapWith:[]},
  {key:'giac_hoi', label:'Gi√°c h∆°i ', duration:5, staffActive:2, patientActive:5, deviceType:'giacHoi', allowOverlapWith:[]},
];

function createPatientCard(idx) {
  const card = document.createElement('div'); 
  card.className = 'card'; 
  card.dataset.index = idx;

  const nameRow = document.createElement('div'); 
  nameRow.className = 'row';
  nameRow.innerHTML = `
    <div style="flex:2 1 360px;">
      <label>T√™n b·ªánh nh√¢n</label>
      <input type="text" class="patient-name" placeholder="Nh·∫≠p t√™n b·ªánh nh√¢n">
    </div>
    <div style="flex:1 1 200px;">
      <label>Gi·ªù v√†o vi·ªán <i>(N·∫øu l·∫ßn ƒë·∫ßu)</i></label>
      <input type="time" class="patient-arrival">
    </div>
    <div style="flex:1 1 240px;">
      <label>Nh√¢n vi√™n ph·ª• tr√°ch</label>
      <select class="patient-staff"></select>
    </div>`;
  card.appendChild(nameRow);

  const procRow = document.createElement('div'); procRow.className = 'row';
  const procWrap = document.createElement('div'); procWrap.style.flex = '2 1 500px';
  const label = document.createElement('label'); label.textContent = 'Th·ªß thu·∫≠t cho b·ªánh nh√¢n n√†y';
  const select = document.createElement('select'); select.className = 'patient-proc-select';
  PROCEDURES.forEach(p => { 
    const opt = document.createElement('option'); 
    opt.value=p.key; 
    opt.textContent=p.label; 
    select.appendChild(opt); 
  });
  const addBtn = document.createElement('button'); 
  addBtn.className='btn btn-small'; 
  addBtn.textContent='Th√™m'; 
  addBtn.style.marginLeft='8px';

 // üîí R√†ng bu·ªôc: ph·∫£i nh·∫≠p t√™n b·ªánh nh√¢n tr∆∞·ªõc khi th√™m th·ªß thu·∫≠t
addBtn.addEventListener('click', () => { 
  const nameInput = card.querySelector('.patient-name');
  if (!nameInput.value.trim()) {
    showPopup('Vui l√≤ng nh·∫≠p t√™n b·ªánh nh√¢n tr∆∞·ªõc khi th√™m th·ªß thu·∫≠t.');
    return;
  }

  const key = select.value; 
  const proc = PROCEDURES.find(p=>p.key===key);

  // üîí R√†ng bu·ªôc: kh√¥ng cho th√™m th·ªß thu·∫≠t tr√πng
  const chips = card.querySelectorAll('.patient-proc-chips .chip');
  for (const ch of chips) {
    if (ch.dataset.key === key) {
      showPopup('Th·ªß thu·∫≠t n√†y ƒë√£ ƒë∆∞·ª£c th√™m cho b·ªánh nh√¢n.');
      return;
    }
  }

  addProcChip(card, proc); 
});

  procWrap.appendChild(label); 
  procWrap.appendChild(select); 
  procWrap.appendChild(addBtn);
  procRow.appendChild(procWrap);

  const chips = document.createElement('div'); chips.className = 'chips patient-proc-chips';
  procRow.appendChild(chips);

  card.appendChild(procRow); 
  patientsEl.appendChild(card); 
  refreshPatientStaffOptions();
}

function addProcChip(card, proc) {
  const chips = card.querySelector('.patient-proc-chips');
  const chip = document.createElement('span'); chip.className = 'chip'; chip.dataset.key = proc.key; chip.innerHTML = `${proc.label} <button class="btn btn-small" style="margin-left:6px;">√ó</button>`;
  chip.querySelector('button').addEventListener('click', ()=>{ chip.remove(); setTimeout(updateMachineVisibility, 0); });
  chips.appendChild(chip); setTimeout(updateMachineVisibility, 0);
}

function refreshPatientStaffOptions() {
  const names = getStaffNames();
  document.querySelectorAll('.patient-staff').forEach(sel => {
    const current = sel.value; sel.innerHTML = '<option value="">(Ch∆∞a ch·ªçn)</option>';
    names.filter(n=>n).forEach(n => { const opt = document.createElement('option'); opt.value=n; opt.textContent=n; sel.appendChild(opt); });
    sel.value = current;
  });
}

function getStaffNames() { return Array.from(staffListEl.querySelectorAll('input[type="text"]')).map(i=>i.value.trim()).filter(Boolean); }

function getPatientsData() {
  const cards = Array.from(patientsEl.querySelectorAll('.card'));
  return cards.map(card => {
    const name = card.querySelector('.patient-name').value.trim();
    const arrival = card.querySelector('.patient-arrival').value;
    const prefStaff = card.querySelector('.patient-staff').value || null;
    const procs = Array.from(card.querySelectorAll('.patient-proc-chips .chip')).map(ch => ch.dataset.key);
    return {name, arrival: arrival || null, prefStaff, procs};
  }).filter(p => p.name && p.procs.length>0);
}

function addPatient() { 
  const existing = Array.from(patientsEl.querySelectorAll('.card'));
  for (const c of existing) {
    const name = c.querySelector('.patient-name').value.trim();
    if (!name) {
      showPopup('H√£y nh·∫≠p t√™n cho b·ªánh nh√¢n hi·ªán t·∫°i tr∆∞·ªõc khi th√™m b·ªánh nh√¢n m·ªõi.');
      return;
    }
  }
  const idx = existing.length; 
  createPatientCard(idx); 
}
addPatient(); addPatientBtn.addEventListener('click', addPatient);
patientsEl.addEventListener('click', (e)=>{ if (e.target.closest('.end-patient')) { addPatient(); } });

/* Machines dynamic names */
function rebuildNameInputs(count, container, type) {
  container.innerHTML = '';
  let prefix = ''; if (type==='dienCham') prefix='ƒêC'; else if (type==='chieuDen') prefix='HN'; else if (type==='giacHoi') prefix='GH';
  for (let i=0;i<count;i++) {
    const wrap = document.createElement('div'); wrap.className='row';
    const inner = document.createElement('div'); inner.style.flex='1 1 220px';
    const label = document.createElement('label'); label.textContent = `${prefix}${i+1}`;
    const input = document.createElement('input'); input.type='text'; input.value=`${prefix}${i+1}`;
    inner.appendChild(label); inner.appendChild(input); wrap.appendChild(inner); container.appendChild(wrap);
  }
}

const nDienCham = document.getElementById('nDienCham');
const nChieuDen = document.getElementById('nChieuDen');
const nGiacHoi = document.getElementById('nGiacHoi');
const dienChamNames = document.getElementById('dienChamNames');
const chieuDenNames = document.getElementById('chieuDenNames');
const giacHoiNames = document.getElementById('giacHoiNames');

nDienCham.addEventListener('input', ()=> rebuildNameInputs(parseInt(nDienCham.value||'0',10), dienChamNames, 'dienCham'));
nChieuDen.addEventListener('input', ()=> rebuildNameInputs(parseInt(nChieuDen.value||'0',10), chieuDenNames, 'chieuDen'));
nGiacHoi.addEventListener('input', ()=> rebuildNameInputs(parseInt(nGiacHoi.value||'0',10), giacHoiNames, 'giacHoi'));

/* Scheduler logic (as before) */
const startBtn = document.getElementById('startBtn');
const outputWrap = document.getElementById('outputWrap');
const resultTableBody = document.querySelector('#resultTable tbody');
const exportCSVBtn = document.getElementById('exportCSV');
const copyCSVBtn = document.getElementById('copyCSV');

function getMachineNames(container) { return Array.from(container.querySelectorAll('input[type="text"]')).map(i=>i.value.trim()).filter(Boolean); }

function buildResources() {
  return {
    staff: getStaffNames().map(n => ({name:n, busy:[]})).filter(s=>s.name),
    machines: {
      dienCham: getMachineNames(dienChamNames).map(n=>({name:n, busy:[]})),
      chieuDen: getMachineNames(chieuDenNames).map(n=>({name:n, busy:[]})),
      giacHoi: getMachineNames(giacHoiNames).map(n=>({name:n, busy:[]})),
    }
  };
}

function isFree(busyIntervals, start, end) { return !busyIntervals.some(b => !(end <= b.start || start >= b.end)); }
function book(busyIntervals, start, end, meta={}) { busyIntervals.push({start, end, ...meta}); }
function addCooldown(busyIntervals, atMinute) { book(busyIntervals, atMinute, atMinute+1, {cooldown:true}); }

function findSlotForTask(task, patient, resources, windows, preferMorning=true) {
  const devicePool = task.deviceType ? resources.machines[task.deviceType] : null;
  const staff = resources.staff.find(s=>s.name===patient.prefStaff);
  if (!staff) return null;
  const parts = preferMorning ? [[windows.morningStart, windows.morningEnd],[windows.afternoonStart, windows.afternoonEnd]] : [[windows.afternoonStart, windows.afternoonEnd],[windows.morningStart, windows.morningEnd]];
  let earliest = Math.max(windows.morningStart, patient.arrivalMin || windows.morningStart);
  for (const [wStart, wEnd] of parts) {
    let t = Math.max(earliest, wStart);
    let overlapAnchor = null;
    if (task.type==='chieu_den' && patient._dienChamPlaced) { overlapAnchor = patient._dienChamStart + 3; t = Math.max(t, overlapAnchor); }
    while (t + task.duration <= wEnd) {
      let patientOK = true;
      if (task.type==='chieu_den' && patient._dienChamPlaced) {
        patientOK = patient.busy.every(pb => { if (pb.type==='xoa_bop' || pb.type==='giac_hoi' || pb.type==='xoa_bop_vung') { return (t+task.patientActive <= pb.start) || (t >= pb.end); } return true; });
      } else { patientOK = isFree(patient.busy, t, t + task.patientActive); }
      if (!patientOK) { t++; continue; }
      const sStart = t; const sEnd = t + task.staffActive; const staffOK = isFree(staff.busy, sStart, sEnd); if (!staffOK) { t++; continue; }
      let chosenDevice = null; if (devicePool) { for (const dev of devicePool) { if (isFree(dev.busy, t, t + task.duration)) { chosenDevice = dev; break; } } if (!chosenDevice) { t++; continue; } }
      return { start:t, end:t+task.duration, staffBusyStart:sStart, staffBusyEnd:sEnd, machine: chosenDevice ? chosenDevice.name : '' };
    }
  }
  return null;
}

function showPopup(msg) {
  document.getElementById('popupMessage').textContent = msg;
  document.getElementById('popupOverlay').style.display = 'flex';
}

function closePopup() {
  document.getElementById('popupOverlay').style.display = 'none';
}
function validateMachineCounts(patients){
  const allProcs = new Set();
  patients.forEach(p => (p.procs||[]).forEach(k => allProcs.add(k)));
  const needsDienCham = allProcs.has('dien_cham');
  const needsChieuDen = allProcs.has('chieu_den');
  const needsGiacHoi = allProcs.has('giac_hoi');

  const missing = [];
  const numDC = parseInt((document.getElementById('nDienCham').value||'0'), 10);
  const numCD = parseInt((document.getElementById('nChieuDen').value||'0'), 10);
  const numGH = parseInt((document.getElementById('nGiacHoi').value||'0'), 10);

  if (needsDienCham && (!Number.isFinite(numDC) || numDC <= 0)) missing.push('m√°y ƒëi·ªán ch√¢m');
  if (needsChieuDen && (!Number.isFinite(numCD) || numCD <= 0)) missing.push('m√°y chi·∫øu ƒë√®n');
  if (needsGiacHoi && (!Number.isFinite(numGH) || numGH <= 0)) missing.push('m√°y gi√°c h∆°i');

  if (missing.length){
    showPopup('Ch∆∞a nh·∫≠p ' + missing.join(', ') + '.');
    return false;
  }
  return true;
}

function scheduleAll() {
  const staffNames = getStaffNames().filter(Boolean);
  if (staffNames.length===0) { showPopup('H√£y nh·∫≠p √≠t nh·∫•t 1 nh√¢n vi√™n.'); return []; }
  const patients = getPatientsData();
  if (patients.length===0) { showPopup('H√£y nh·∫≠p √≠t nh·∫•t 1 b·ªánh nh√¢n v√† th·ªß thu·∫≠t.'); return []; }

  if (!validateMachineCounts(patients)) { return []; }

  const windows = {
    morningStart: toMin(document.getElementById('morningStart').value),
    morningEnd: toMin(document.getElementById('morningEnd').value),
    afternoonStart: toMin(document.getElementById('afternoonStart').value),
    afternoonEnd: toMin(document.getElementById('afternoonEnd').value),
  };

  const resources = buildResources();
  patients.forEach(p=>{ p.busy=[]; p.arrivalMin = p.arrival ? toMin(p.arrival) : null; p._dienChamPlaced=false; p._dienChamStart=null; });

  const results = [];
  for (const p of patients) {
    for (const key of p.procs) {
      if (key==='chieu_den' && p.procs.includes('dien_cham') && !p._dienChamPlaced) { continue; }
      const def = PROCEDURES.find(x=>x.key===key); if (!def) continue;
      const slot = findSlotForTask({type:def.key, duration:def.duration, staffActive:def.staffActive, patientActive:def.patientActive, deviceType:def.deviceType, allowOverlapWith:def.allowOverlapWith}, p, resources, windows, true)
                || findSlotForTask({type:def.key, duration:def.duration, staffActive:def.staffActive, patientActive:def.patientActive, deviceType:def.deviceType, allowOverlapWith:def.allowOverlapWith}, p, resources, windows, false);
      if (!slot) {
        results.push({patient:p.name, proc:def.label, staff:p.prefStaff||'', machine:'', start:'', end:'', staffBusy:'', note:'Kh√¥ng t√¨m ƒë∆∞·ª£c slot ph√π h·ª£p'});
        continue;
      }
      commitBooking(p, def, slot, resources, results);
    }
    if (p.procs.includes('dien_cham') && p.procs.includes('chieu_den')) {
      if (!p._chieuTried && !p.busy.some(b => b.type==='chieu_den')) {
        p._chieuTried = true;
        const def = PROCEDURES.find(x=>x.key==='chieu_den');
        const slot = findSlotForTask({type:def.key, duration:def.duration, staffActive:def.staffActive, patientActive:def.patientActive, deviceType:def.deviceType, allowOverlapWith:def.allowOverlapWith}, p, resources, windows, true)
                  || findSlotForTask({type:def.key, duration:def.duration, staffActive:def.staffActive, patientActive:def.patientActive, deviceType:def.deviceType, allowOverlapWith:def.allowOverlapWith}, p, resources, windows, false);
        if (slot) commitBooking(p, def, slot, resources, results);
        else results.push({patient:p.name, proc:def.label, staff:p.prefStaff||'', machine:'', start:'', end:'', staffBusy:'', note:'Kh√¥ng t√¨m ƒë∆∞·ª£c slot ph√π h·ª£p'});
      }
    }
  }
  results.sort((a,b)=> a.patient.localeCompare(b.patient, 'vi'));
  return results;
}

function commitBooking(p, def, slot, resources, results) {
  const staff = resources.staff.find(s=>s.name===p.prefStaff);
  book(p.busy, slot.start, slot.end, {type:def.key}); addCooldown(p.busy, slot.end + 0);
  if (staff) { book(staff.busy, slot.staffBusyStart, slot.staffBusyEnd, {patient:p.name, type:def.key}); addCooldown(staff.busy, slot.staffBusyEnd + 0); }
  if (def.deviceType && slot.machine) { const pool = resources.machines[def.deviceType]; const dev = pool.find(d=>d.name===slot.machine); if (dev) book(dev.busy, slot.start, slot.end, {patient:p.name, type:def.key}); }
  if (def.key==='dien_cham') { p._dienChamPlaced=true; p._dienChamStart=slot.start; }
  results.push({ patient:p.name, proc:def.label, staff:p.prefStaff||'', machine:slot.machine||'', start:toHHMM(slot.start), end:toHHMM(slot.end), staffBusy:`${toHHMM(slot.staffBusyStart)}‚Äì${toHHMM(slot.staffBusyEnd)}`, note:(def.key==='chieu_den' && p._dienChamPlaced && slot.start >= p._dienChamStart+3) ? 'Chi·∫øu ƒë√®n ch·ªìng l√™n ƒêi·ªán ch√¢m' : '' });
}

/* Render results */
function renderTable(rows) {
  resultTableBody.innerHTML = '';
  for (const r of rows) {
    const tr = document.createElement('tr');
    tr.innerHTML = `<td>${r.patient}</td><td>${r.proc}</td><td>${r.staff}</td><td>${r.machine}</td><td>${r.start}</td><td>${r.end}</td><td>${r.staffBusy}</td><td>${r.note}</td>`;
    resultTableBody.appendChild(tr);
  }
}

function rowsToCSV(rows) {
  const header = ['B·ªánh nh√¢n','Th·ªß thu·∫≠t','Nh√¢n vi√™n','M√°y','B·∫Øt ƒë·∫ßu','K·∫øt th√∫c','Nh√¢n vi√™n b·∫≠n','Ghi ch√∫'];
  const esc = v => `"${String(v||'').replace(/"/g,'""')}"`;
  return [header.map(esc).join(','), ...rows.map(r=>[r.patient,r.proc,r.staff,r.machine,r.start,r.end,r.staffBusy,r.note].map(esc).join(','))].join('\n');
}

/* ===== Export buttons (same) ===== */
exportCSVBtn.addEventListener('click', ()=>{
  const rows = Array.from(resultTableBody.querySelectorAll('tr')).map(tr=>({ patient: tr.children[0].textContent, proc: tr.children[1].textContent, staff: tr.children[2].textContent, machine: tr.children[3].textContent, start: tr.children[4].textContent, end: tr.children[5].textContent, staffBusy: tr.children[6].textContent, note: tr.children[7].textContent, }));
  const csv = rowsToCSV(rows);
  const blob = new Blob([csv], {type:'text/csv;charset=utf-8;'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href=url; a.download='lich_thu_thuat.csv'; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
});

copyCSVBtn.addEventListener('click', async ()=>{
  const rows = Array.from(resultTableBody.querySelectorAll('tr')).map(tr=>({ patient: tr.children[0].textContent, proc: tr.children[1].textContent, staff: tr.children[2].textContent, machine: tr.children[3].textContent, start: tr.children[4].textContent, end: tr.children[5].textContent, staffBusy: tr.children[6].textContent, note: tr.children[7].textContent, }));
  const csv = rowsToCSV(rows);
  try { await navigator.clipboard.writeText(csv); showPopup('ƒê√£ copy CSV v√†o clipboard.'); }
  catch(e) { showPopup('Kh√¥ng copy ƒë∆∞·ª£c. H√£y d√πng n√∫t T·∫£i CSV.'); }
});

/* Excel export (kept) */
document.getElementById('exportExcel').addEventListener('click', () => {
  const toHHMMSS = (t) => (t && t.includes(':')) ? (t.length === 5 ? t + ':00' : t) : '';
  const rows = Array.from(document.querySelectorAll('#resultTable tbody tr')).map((tr, i) => {
   const tds = Array.from(tr.children).map(td => td.textContent.trim());
   const stt = i + 1; const hoTen = tds[0] || ''; const thuThuat = tds[1] || ''; const nhanVien = tds[2] || ''; const batDau = tds[4] || ''; const ketThuc = tds[5] || '';
   const now = new Date(); const dd = String(now.getDate()).padStart(2,'0'); const mm = String(now.getMonth()+1).padStart(2,'0'); const yyyy = now.getFullYear();
   const ngayThucHien = `${dd}/${mm}/${yyyy}`;
   const tgBatDauText = `${ngayThucHien}\r\n${toHHMMSS(batDau)}`; const tgKetThucText = `${ngayThucHien}\r\n${toHHMMSS(ketThuc)}`;
   return [ stt, hoTen, '', '', '', '', '', '', '', thuThuat, ngayThucHien, tgBatDauText, tgKetThucText, '', nhanVien, '' ];
 });
 const titleBlock = [ ['S·ªû Y T·∫æ T·ªàNH QU·∫¢NG NAM', ...Array(15).fill(null)], ['B·ªÜNH VI·ªÜN Y H·ªåC C·ªî TRUY·ªÄN', ...Array(15).fill(null)], [], ['S·ªî TH·ª¶ THU·∫¨T', ...Array(15).fill(null)], ['Ng√†y h√¥m nay', ...Array(15).fill(null)], ['Khoa N·ªôi', ...Array(15).fill(null)], [], [ 'STT','H·ªç t√™n','M√£ BN','M√£ ƒëi·ªÅu tr·ªã','Tu·ªïi','Nh√≥m PTTT','S·ªë l∆∞·ª£ng','NƒÉm sinh', 'Th·ªß thu·∫≠t','Ng√†y th·ª±c hi·ªán','Th·ªùi gian b·∫Øt ƒë·∫ßu th·ª±c hi·ªán','Th·ªùi gian k·∫øt th√∫c','B√°c s·ªπ ch·ªâ ƒë·ªãnh','Th·ªß thu·∫≠t ch√≠nh','ƒêi·ªÅu d∆∞·ª°ng th·ª±c hi·ªán' ], [ '','','','','','','','Nam','N·ªØ','','','','','','','' ], ];
 const data = [...titleBlock, ...rows];
 const ws = XLSX.utils.aoa_to_sheet(data);
 ws['!merges'] = [ {s:{r:0,c:0}, e:{r:0,c:15}}, {s:{r:1,c:0}, e:{r:1,c:15}}, {s:{r:3,c:0}, e:{r:3,c:15}}, {s:{r:4,c:0}, e:{r:4,c:15}}, {s:{r:5,c:0}, e:{r:5,c:15}}, ...[0,1,2,3,4,5,6,9,10,11,12,13,14,15].map(c => ({s:{r:7,c}, e:{r:8,c}})), {s:{r:7,c:7}, e:{r:7,c:8}}, ];
 ws['!cols'] = [ {wch:4}, {wch:22}, {wch:10}, {wch:12}, {wch:6}, {wch:12}, {wch:8}, {wch:6}, {wch:6}, {wch:26}, {wch:14}, {wch:22}, {wch:20}, {wch:18}, {wch:18}, {wch:20}, ];
 const setCenterBold = (addr) => { if (ws[addr]) ws[addr].s = {alignment:{horizontal:'center', vertical:'center'}, font:{bold:true}}; };
 ['A1','A2','A5','A7','A8'].forEach(setCenterBold);
 const wrapCols = [ 'A8','B8','C8','D8','E8','F8','G8','H8','I8','J8','K8','L8','M8','N8','O8','P8' ];
 wrapCols.forEach(a => { if (ws[a]) { ws[a].s = { alignment: { wrapText: true, horizontal: 'center', vertical: 'center' }, font: { bold: true } }; } });
 const headerRows = titleBlock.length; const dataRowCount = rows.length;
 for (let r = 0; r < dataRowCount; r++) { const rr = headerRows + r; const addrL = XLSX.utils.encode_cell({ r: rr, c: 11 }); const addrM = XLSX.utils.encode_cell({ r: rr, c: 12 }); [addrL, addrM].forEach(addr => { if (ws[addr]) { ws[addr].t = 's'; ws[addr].v = String(ws[addr].v || ''); ws[addr].s = { alignment: { wrapText: true, horizontal: 'center', vertical: 'center' } }; } }); }
 const wb = XLSX.utils.book_new(); XLSX.utils.book_append_sheet(wb, ws, 'S·ªï Th·ªß Thu·∫≠t'); XLSX.writeFile(wb, 'so_thu_thuat.xlsx');
});

/* ====== Dropbox-backed History (replacing localStorage) ====== */

/* Utility: format */
function fmt2(n){ return n<10 ? '0'+n : ''+n; }
function makeFilename(ts, rows){
  let staffNames = getStaffNames();
  let prefix = staffNames.length > 0 ? staffNames[0].replace(/\s+/g,'_') : 'Lich';
  const d=new Date(ts);
  return `${prefix}_${d.getFullYear()}${fmt2(d.getMonth()+1)}${fmt2(d.getDate())}_${fmt2(d.getHours())}${fmt2(d.getMinutes())}${fmt2(d.getSeconds())}`;
}

function getUniquePatients(rows){ return Array.from(new Set(rows.map(r=>r.patient).filter(Boolean))); }

/* Save history to Dropbox: creates item file and updates index.json */
async function saveHistory(rows){
  try {
    await ensureBaseFolder();
  } catch(e){
    console.warn('ensureBaseFolder failed', e);
  }
  const ts = Date.now();
  const id = String(ts);
  const name = makeFilename(ts, rows);
  const patients = getUniquePatients(rows);
  const meta = { id, name, createdAt: ts, rowCount: rows.length, patientCount: patients.length };
  const payload = { meta, rows };

  try {
    // upload item
    const p = itemPath(id);
    await dropboxUpload(p, JSON.stringify(payload), 'overwrite');

    // load index
    let idx = [];
    try {
      const raw = await dropboxDownload(indexPath());
      if (raw) idx = JSON.parse(raw);
    } catch(e) { idx = []; }

    idx.push(meta);
    if (idx.length > 200) {
      const remove = idx.splice(0, idx.length - 200);
      // delete the removed files
      for (const it of remove) {
        try { await dropboxDelete(itemPath(it.id)); } catch(e){ console.warn('delete old item error', e); }
      }
    }
    // save index (overwrite)
    await dropboxUpload(indexPath(), JSON.stringify(idx), 'overwrite');
    showPopup('ƒê√£ l∆∞u l·ªãch s·ª≠ s·∫Øp x·∫øp.');
  } catch (e) {
    console.error(e);
    showPopup('L·ªói khi l∆∞u l·ªãch s·ª≠: ' + (e.message || e));
  }
}

/* Render history list by downloading index.json from Dropbox */
/* ==== L·ªäCH S·ª¨ ==== */
async function renderHistoryList(){
  historyListBody.innerHTML = '';
  // Hi·ªán d√≤ng "ƒêang t·∫£i d·ªØ li·ªáu‚Ä¶" ngay trong b·∫£ng
  const loadingTr = document.createElement('tr');
  const loadingTd = document.createElement('td');
  loadingTd.colSpan = 6;
  loadingTd.style.textAlign = 'center';
  loadingTd.textContent = 'ƒêang t·∫£i d·ªØ li·ªáu‚Ä¶';
  loadingTr.appendChild(loadingTd);
  historyListBody.appendChild(loadingTr);

  try {
    const raw = await dropboxDownload(indexPath());
    if (!raw) {
      historyListBody.innerHTML = '<tr><td colspan="6" style="text-align:center;">Ch∆∞a c√≥ l·ªãch s·ª≠ n√†o.</td></tr>';
      return;
    }

    let idx = JSON.parse(raw);
    idx = idx.slice().sort((a,b)=>b.createdAt - a.createdAt);

    if (idx.length===0) {
      historyListBody.innerHTML = '<tr><td colspan="6" style="text-align:center;">Ch∆∞a c√≥ l·ªãch s·ª≠ n√†o.</td></tr>';
      return;
    }

    historyListBody.innerHTML = '';
    idx.forEach(item=>{
      const tr=document.createElement('tr');
      const d = new Date(item.createdAt);
      const when = `${fmt2(d.getDate())}/${fmt2(d.getMonth()+1)}/${d.getFullYear()} ${fmt2(d.getHours())}:${fmt2(d.getMinutes())}:${fmt2(d.getSeconds())}`;
      tr.innerHTML = `
        <td class="nowrap">${item.name}</td>
        <td class="nowrap">${when}</td>
        <td class="nowrap" style="text-align:center;">${item.rowCount}</td>
        <td class="nowrap" style="text-align:center;">${item.patientCount}</td>
        <td class="nowrap"><button class="btn btn-small" data-act="view" data-id="${item.id}">Xem</button></td>
        <td class="nowrap"><button class="btn btn-small" data-act="del" data-id="${item.id}">X√≥a</button></td>`;
      historyListBody.appendChild(tr);
    });
  } catch (e) {
    console.error(e);
    historyListBody.innerHTML = '<tr><td colspan="6" style="text-align:center;">Kh√¥ng th·ªÉ t·∫£i danh s√°ch l·ªãch s·ª≠.</td></tr>';
  }
}

/* Open history detail: download specific item file */
async function openHistoryDetail(id){
  try {
    const raw = await dropboxDownload(itemPath(id));
    if (!raw) { showPopup('Kh√¥ng t√¨m th·∫•y d·ªØ li·ªáu l·ªãch s·ª≠.'); return; }
    let data;
    try { data = JSON.parse(raw); } catch(e){ showPopup('D·ªØ li·ªáu l·ªãch s·ª≠ b·ªã l·ªói.'); return; }
    const { meta, rows } = data;
    historyDetailTitle.textContent = `L·ªãch th·ªß thu·∫≠t ƒë√£ s·∫Øp ¬∑ ${meta.name}`;
    historyDetailBody.innerHTML='';
    rows.forEach(r=>{
      const tr = document.createElement('tr');
      tr.innerHTML = `<td>${r.patient}</td><td>${r.proc}</td><td>${r.staff}</td><td>${r.machine}</td><td>${r.start}</td><td>${r.end}</td><td>${r.staffBusy}</td><td>${r.note}</td>`;
      historyDetailBody.appendChild(tr);
    });
    historyDetailOverlay.style.display='flex';
  } catch (e) {
    console.error(e);
    showPopup('L·ªói khi t·∫£i d·ªØ li·ªáu l·ªãch s·ª≠: ' + (e.message || e));
  }
}

/* Delete a single history item: delete file and update index */
async function deleteHistoryItem(id){
  try {
    // delete file
    await dropboxDelete(itemPath(id));
  } catch(e){ console.warn('dropbox delete item failed', e); }
  try {
    // update index
    let idx = [];
    try { const raw = await dropboxDownload(indexPath()); if (raw) idx = JSON.parse(raw); } catch(e){ idx = []; }
    idx = idx.filter(x=>x.id!==id);
    await dropboxUpload(indexPath(), JSON.stringify(idx), 'overwrite');
  } catch(e){
    console.warn('update index after delete failed', e);
  }
}

/* Clear all history */
async function clearAllHistory(){
  try {
    let idx = [];
    try { const raw = await dropboxDownload(indexPath()); if (raw) idx = JSON.parse(raw); } catch(e){ idx = []; }
    for (const it of idx) {
      try { await dropboxDelete(itemPath(it.id)); } catch(e){ console.warn('delete item', it.id, 'failed', e); }
    }
    // write empty index
    await dropboxUpload(indexPath(), JSON.stringify([]), 'overwrite');
    showPopup('ƒê√£ x√≥a to√†n b·ªô l·ªãch s·ª≠ tr√™n m√°y ch·ªß.');
  } catch(e){
    console.error(e);
    showPopup('L·ªói khi x√≥a l·ªãch s·ª≠: ' + (e.message || e));
  }
}

/* UI wiring for history list */
const historyBtn = document.getElementById('historyBtn');
const historyOverlay = document.getElementById('historyOverlay');
const historyListBody = document.getElementById('historyListBody');
const closeHistoryBtn = document.getElementById('closeHistoryBtn');
const clearHistoryBtn = document.getElementById('clearHistoryBtn');

const historyDetailOverlay = document.getElementById('historyDetailOverlay');
const historyDetailBody = document.getElementById('historyDetailBody');
const historyDetailTitle = document.getElementById('historyDetailTitle');
const closeHistoryDetailBtn = document.getElementById('closeHistoryDetailBtn');

function openHistoryList(){ renderHistoryList(); historyOverlay.style.display='flex'; }
function closeHistoryList(){ historyOverlay.style.display='none'; }



closeHistoryBtn.addEventListener('click', closeHistoryList);

closeHistoryDetailBtn.addEventListener('click', ()=>{ historyDetailOverlay.style.display='none'; });

[historyOverlay, historyDetailOverlay].forEach(ov=>{
  ov.addEventListener('click', (e)=>{ if (e.target===ov) ov.style.display='none'; });
});

/* Start scheduling + save history (startBtn becomes async) */
startBtn.addEventListener('click', async ()=>{
  const rows = scheduleAll();
  if (rows.length) { outputWrap.classList.remove('hidden'); renderTable(rows); await saveHistory(rows); }
});

/* Machines visibility management (same behavior) */
const machinesCard = document.getElementById('machinesCard');
const dienChamRow = nDienCham.closest('.row');
const chieuDenRow = nChieuDen.closest('.row');
const giacHoiRow = nGiacHoi.closest('.row');
machinesCard.style.display = 'none'; dienChamRow.style.display = 'none'; chieuDenRow.style.display = 'none'; giacHoiRow.style.display = 'none';
patientsEl.addEventListener('click', (e) => { if (e.target.closest('.btn') && e.target.textContent.trim() === 'Th√™m') { setTimeout(updateMachineVisibility, 0); } });
patientsEl.addEventListener('click', (e) => { if (e.target.tagName === 'BUTTON' && e.target.textContent.trim() === '√ó') { setTimeout(updateMachineVisibility, 0); } });
function updateMachineVisibility() {
  const procs = Array.from(document.querySelectorAll('.patient-proc-chips .chip')).map(ch => ch.dataset.key);
  const hasDienCham = procs.includes('dien_cham'); const hasChieuDen = procs.includes('chieu_den'); const hasGiacHoi = procs.includes('giac_hoi');
  machinesCard.style.display = (hasDienCham || hasChieuDen || hasGiacHoi) ? '' : 'none';
  dienChamRow.style.display = hasDienCham ? '' : 'none';
  chieuDenRow.style.display = hasChieuDen ? '' : 'none';
  giacHoiRow.style.display = hasGiacHoi ? '' : 'none';
}

/* small confirm popup helper (reused) */
function showConfirmPopup(message, onConfirm){
  const overlay = document.createElement('div');
  overlay.style.position = 'fixed';
  overlay.style.inset = 0;
  overlay.style.background = 'rgba(0,0,0,0.5)';
  overlay.style.display = 'flex';
  overlay.style.alignItems = 'center';
  overlay.style.justifyContent = 'center';
  overlay.style.zIndex = 10000;

  const box = document.createElement('div');
  box.style.background = '#fff';
  box.style.padding = '20px';
  box.style.borderRadius = '12px';
  box.style.maxWidth = '320px';
  box.style.textAlign = 'center';
  box.style.boxShadow = '0 6px 20px rgba(0,0,0,0.25)';

  const msg = document.createElement('div');
  msg.textContent = message;

  const btnWrap = document.createElement('div');
  btnWrap.style.marginTop = '14px';
  btnWrap.style.display = 'flex';
  btnWrap.style.justifyContent = 'center';
  btnWrap.style.gap = '12px';

  const okBtn = document.createElement('button');
  okBtn.textContent = 'OK';
  okBtn.className = 'btn btn-small';
  okBtn.style.background = 'var(--acc)';
  okBtn.style.color = '#fff';
  okBtn.onclick = ()=>{ document.body.removeChild(overlay); onConfirm(); };

  const cancelBtn = document.createElement('button');
  cancelBtn.textContent = 'H·ªßy';
  cancelBtn.className = 'btn btn-small';
  cancelBtn.onclick = ()=>{ document.body.removeChild(overlay); };

  btnWrap.appendChild(okBtn);
  btnWrap.appendChild(cancelBtn);
  box.appendChild(msg);
  box.appendChild(btnWrap);
  overlay.appendChild(box);
  document.body.appendChild(overlay);
}

/* Open history button */
historyBtn.addEventListener('click', async ()=>{ openHistoryList(); });
const DELETE_PASSWORD = "1!"; // ƒë·ªïi m·∫≠t kh·∫©u ·ªü ƒë√¢y

function showPasswordPopup(message, onConfirm) {
  const overlay = document.createElement('div');
  overlay.style.position = 'fixed';
  overlay.style.inset = 0;
  overlay.style.background = 'rgba(0,0,0,0.5)';
  overlay.style.display = 'flex';
  overlay.style.alignItems = 'center';
  overlay.style.justifyContent = 'center';
  overlay.style.zIndex = 10001;

  const box = document.createElement('div');
  box.style.background = '#fff';
  box.style.padding = '20px';
  box.style.borderRadius = '12px';
  box.style.maxWidth = '320px';
  box.style.textAlign = 'center';
  box.style.boxShadow = '0 6px 20px rgba(0,0,0,0.25)';

  const msg = document.createElement('div');
  msg.textContent = message;

  const input = document.createElement('input');
  input.type = 'password';
  input.placeholder = 'Nh·∫≠p m·∫≠t kh·∫©u';
  input.style.marginTop = '12px';
  input.style.padding = '8px';
  input.style.width = '100%';
  input.style.border = '1px solid #ccc';
  input.style.borderRadius = '8px';

  const errorMsg = document.createElement('div');
  errorMsg.style.color = 'red';
  errorMsg.style.marginTop = '6px';
  errorMsg.style.fontSize = '13px';
  errorMsg.style.display = 'none';
  errorMsg.textContent = 'Sai m·∫≠t kh·∫©u!';

  const btnWrap = document.createElement('div');
  btnWrap.style.marginTop = '14px';
  btnWrap.style.display = 'flex';
  btnWrap.style.justifyContent = 'center';
  btnWrap.style.gap = '12px';

  const okBtn = document.createElement('button');
  okBtn.textContent = 'X√°c nh·∫≠n';
  okBtn.className = 'btn btn-small';
  okBtn.style.background = 'var(--acc)';
  okBtn.style.color = '#fff';
  okBtn.onclick = ()=>{
    if (input.value === DELETE_PASSWORD) {
      document.body.removeChild(overlay);
      onConfirm();
    } else {
      errorMsg.style.display = 'block';
      input.value = '';
      input.focus();
    }
  };

  const cancelBtn = document.createElement('button');
  cancelBtn.textContent = 'H·ªßy';
  cancelBtn.className = 'btn btn-small';
  cancelBtn.onclick = ()=>{ document.body.removeChild(overlay); };

  btnWrap.appendChild(okBtn);
  btnWrap.appendChild(cancelBtn);
  box.appendChild(msg);
  box.appendChild(input);
  box.appendChild(errorMsg);
  box.appendChild(btnWrap);
  overlay.appendChild(box);
  document.body.appendChild(overlay);
}

/* Thay ƒë·ªïi c√°c ch·ªó g·ªçi confirm tr∆∞·ªõc ƒë√¢y ƒë·ªÉ y√™u c·∫ßu m·∫≠t kh·∫©u */
historyListBody.addEventListener('click', async (e)=>{
  const btn = e.target.closest('button'); if (!btn) return;
  const id = btn.getAttribute('data-id'); const act = btn.getAttribute('data-act');
  if (act==='view') {
    await openHistoryDetail(id);
  } else if (act==='del') {
    showPasswordPopup('Nh·∫≠p m·∫≠t kh·∫©u ƒë·ªÉ x√≥a l·ªãch s·ª≠ n√†y:', async ()=>{
      await deleteHistoryItem(id);
      await renderHistoryList();
    });
  }
});

clearHistoryBtn.addEventListener('click', ()=>{
  showPasswordPopup('Nh·∫≠p m·∫≠t kh·∫©u ƒë·ªÉ x√≥a to√†n b·ªô l·ªãch s·ª≠:', async ()=>{
    await clearAllHistory();
    await renderHistoryList();
  });
});
</script>

<footer style="text-align:center; padding:20px; color:var(--muted); font-size:14px;">Design by <strong>Dr.Ch√¢u</strong></footer>
</body>
</html>
